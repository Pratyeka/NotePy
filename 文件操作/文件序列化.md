### 序列化与反序列化
- 序列化用途：
    - 将内存中的字典、列表、集合以及各种对象保存到文件中
    - 将自己定义的类实例，保存到文件中
- 反序列化用途：
    - 从文件中读取数据，并让它们在内存中变成自己对应的类的实例

- 序列化：根据设定的协议，将内存对象转换成特定的字节流
    - 持久化：将字节流存在文件中
- 反序列化：根据设定的协议，将一个特定的字节流恢复到内存中

### pickle模块
- Python中的序列化、反序列化模块
- `pickle.dumps(obj)`: 将obj序列化成一个字节流（不存储，内存变量）
- `pickle.dump(obj, fileobj)`: 将obj对象序列化后存储在file中
- `pickle.loads(bytes)`: 将一个字节流反序列化
- `pickle.load(fileobj)`: 从文本对象中获取字节流后反序列化
- **pickle模块只可以在Python程序之间完成序列化与反序列化，为了完成跨平台、跨语言操作，有XML/json/protocol buffer/messagePack**
```Python
    import pickle
    class A:
        ttt = 'ABD'
        def show(self):
            print('abc')

    filep = 'doc/seq.txt'
    d = {'a':1, 'b':'abd', 'c':[1,2,2]}
    l = list('abdcd')
    i = 99

    with open(filep, 'wb') as f:
        pickle.dump(d,f)
        pickle.dump(l,f)
        pickle.dump(i,f)

    with open(filep, 'rb') as f:
        print(f.read(), f.seek(0))
        for _ in range(3):
            x = pickle.load(f)
            print(type(x), x)

    a1 = A()
    a1.ttt = 100
    sr = pickle.dumps(a1)
    print('sr={}'.format(sr))

    # 反序列化找到类就可以恢复一个对象
    a2 = pickle.loads(sr)
    print(a2.ttt)
    a2.show()
```
- 自定义数据类型：实例的属性会被序列化 共有属性不会被序列化
- 注：序列化、反序列化必须保证使用同一套类的定义，否则会造成错误

### json模块
- 值：双引号引起来的字符串，数值，bool值，null，对象，数组
    - 字符串：有双引号包围起来的任意字符的组合，可以有转义字符
    - 数值：正负数、整数、浮点数
    - 对象：无序的键值对的集合，其中
        - key必须是一个字符串，双引号包围的字符串
        - value可以是任意合法的数值
    - 数组：有组值的集合
- json支持的操作与pickle一致
- 自定义类的序列化与反序列化
    - pass


### MessagePack模块
- 安装：`pip install magpack-python`
- 使用：`import msgpack`
    - 模块方法与pickle一致
- 自定义类的序列化与反序列化
    - pass
