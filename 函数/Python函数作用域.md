***
### 函数返回值
- 省略return语句的情况下默认： `return None`
- 可以有多个return语句，但是只会执行其中一个
- 函数不能同时返回多个值
    - `return 1,2,3`：表示返回一个元祖
- return作用：结束函数调用，返回值
- 函数返回容器类数据时，可以使用解构来提取数据

***
### 参数作用域
标示符的可见范围（变量的可见范围）
- building-in作用域：内建的变量，在解释器启动就已加载到内存中
- 全局作用域：在整个程序运行环境中都可见
- 局部作用域：在*函数、类*内部可见，使用范围不超过其所在的局部作用域
    - 超过变量的局部作用域，会抛出NameError异常
```
                        for循环是否开启作用域？
    对于大部分语言而言，for循环会引入一个新的作用域，但Python不太一样
    for后的变量在循环结束后不会被删除，但如果for循环的序列为空，这些变量不会被赋值
```
- Eclosing： 嵌套函数的外层函数的作用域

### 作用域栗子
```Python
    def add(d):
        def _add():
            d = d + 1 # d += 1
            print(d)
        print(d)
```
- 上述代码执行时抛出异常：引用了未定义的变量
- `d = d + 1`，**在编译函数的定义体时**：定义了d为局部变量（字节码可看）
- 在执行d+1的表达式时，会在局部作用域中查找，发现d没有赋值，抛出异常
- *赋值语句的执行顺序是：先右后左*

```python
    add = logger(add)  #装饰器语法
```
- 上面代码不会报错，因为**在编译函数的定义体时**，定义了add对象的作用域
- 在执行logger(add)表达式的时候，在当前的作用域中可以找到add对象

***
### 参数访问规矩
- 外层作用域中的变量在内层作用域中可见
- 内层作用域中的变量在外层作用域中不可见
- 内层作用域中重新定义同名变量，不会影响外层中的变量
- **参数访问限制突破**
    1. 全局变量关键字global：参数的作用范围包括全局作用域以及当前作用域
        - 在全局作用域中必须有设定的参数
        - 在当前函数的局部作用域中修改参数，也会直接对全局变量修改
        - 作用域不会影响到嵌套的函数内部
    2. 自由变量关键字nonlocal：变量定义为自由变量
        - 声明变量定义在当前作用域的上一层局部作用域中
        - 变量只能是局部作用域的，不能是全局作用域
    - *注意*：上面两个关键字在定义阶段改变参数的作用域

***
### 自由变量与闭包
- 自由变量：内层函数引用到了外层函数中的变量
    - 未在本地作用域中定义的非全局变量
    - 只会出现在函数嵌套结构中

- 闭包定义：
    - 闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定
- 闭包特点：
    - 内层函数引用了外层函数作用域的自由变量
    - 只能出现在函数嵌套结构中
    - 是一个包含了函数和引用自由变量的代码块
    - 引用自由变量的值被保存在函数对象的__closure__属性中（地址）

- 函数对象的__code__属性中保存局部变量和自由变量的名称
    - __code__.co_varnames: 局部变量名称
    - __code__.co_freevars: 自由变量名称（与__closure__对应）

***
### 默认（缺省）值参数的作用域
默认值定义在当前作用域中

```Python
    def foo(x = 1):
        print(x)

    foo()   # 1
    foo()   # 1

    def foo(x = []):
        x.append(1)
        print(x)
    foo()   #[1]
    foo()   #[1,1]
    print(foo.__defaults__)
```

- Python中函数也是对象，参数默认（缺省）值存放在__defaults__属性中
    - 默认值会构成一个元祖结构
    - 函数的生命周期内，属性会一直存在（容器类参数 多次调用出现默认值累积现象）
        - *注意*：函数定义完成后，就产生了一个类对象，绑定在标识符fooName上
    - *如果默认值是引用类型，可能会引起默认值的变化*
- key类型的参数默认值存放在__kwdefaults__属性中
    - 默认值会构成字典结构
- 实参为引用类型数据
    - 实参内容不可被修改：使用影子拷贝
        - 要使用修改后的数据，将影子拷贝变量作为返回值返回
    - 实参内容需要被修改：将该参数传给位置参数
        - 形参使用None缺省值
        - 根据实参值类型选择新建列表还是直接修改列表
```Python
    def foo(x = []):
        x = x[:]       # 使用影子拷贝来防止修改缺省参数
        x.append(1)
        print(x)
    foo()   #[1]
    foo()   #[1,1]

    print(foo.__defaults__)


    def foo(x = None):
        if not x:      # 使用不可变的默认值，传入实参就直接修改实参
            x = []
        x.append(1)
        print(x)
    foo()   #[1]
    foo()   #[1,1]

    print(foo.__defaults__)
```


***
### 全局函数销毁
- 函数也是对象，可以使用del函数来删除标示符
- 定义同名函数，即可作废上一个函数
- 程序结束时，函数可销毁
```Python
    def foo(x = None):
        if not x:
            x = []
        x.append(1)
        print(x)
    print(id(foo))

    def foo(x=1):
        print(x)
    print(id(foo))

    del foo

    print(id(foo))  # NameError
```

### 局部函数销毁
- 在上级函数中定义同名函数
- 使用del语句来销毁函数
- 上级作用域销毁时，函数销毁

