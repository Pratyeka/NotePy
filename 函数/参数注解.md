### 动态语言函数定义弊端
- Python是动态语言，变量可以随时被赋值为不同的类型
- 动态语言在运行期才能将问题显现出来，或者线上运行时才能暴露出问题

***
解决动态语言函数弊端的方法：
### 函数注解（文档字符串） ###
- *注：只是惯例，不是强制要求*
- 使用`""" """` 或者 `''' '''`来完成函数注解 
- 要求从函数语句块的第一行开始写
- 习惯：
    - 第一行写函数的概述
    - 第二行空行
    - 第三行开始写详细内容（可以加入对参数类型的注解）

- *存在的问题：*
    - 函数多次修改后，文档没有及时修改，造成代码阅读困惑

***
### 参数注解 ###
- 语法形式：`def fName(x:int, y:float=4, *args,z:str,**kwargs)->int:`
- 参数注解只是提供辅助分析，不会强制类型检查（提供给第三方工具，做代码分析）
- fName.__annotations__属性，以普通字典形式保存函数的注解信息（包括返回值类型注解）
    - 可变参数没有对应的类型注解
    - *函数也是对象，对象就有属性*
    - 在做位置参数类型检查时，无法正确的匹配输入与形参的对应关系(因为字典乱序)

```python
def add(x:int,y:int,z:int=0,j:int=0,*args,k:float=3.0,m:float,**kwargs)->int:
    return x+y+z+j
print(add.__annotations__)
# {'x': <class 'int'>, 'y': <class 'int'>, 
# 'z': <class 'int'>, 'j': <class 'int'>, 
# 'k': <class 'float'>, 'm': <class 'float'>, 
# 'return': <class 'int'>}
```

***
- 在python3.6中引入了变量注解 `i:int = 3`

***
### inspect模块对参数类型进行检查分析
- 可以使用装饰器、insepct模块来完成对类型的检查
    - inspect模块的signature可以获取函数的签名信息
```python
from inspect import signature

def add(x:int,y:int,z:int=0,j:int=0,*args,k:float=3.0,m:float,**kwargs)->int:
    return x+y+z+j

print(signature(add))
# (x:int, y:int, z:int=0, j:int=0, *args, k:float=3.0, m:float, **kwargs) -> int
```
-  *[inspect模块的signature方法介绍](https://github.com/Pratyeka/NotePy/blob/master/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97.md)*



- 参数类型检查代码：
```python
# M2: -----------------------------
# 原函数中有可变参数（完整版本的类型匹配）
# 首先判定位置参数、跳过可变位置参数、对kv对参数进行判定(跳过可变关键字参数)
import inspect
import functools

def check(fn):
    @functools.wraps(fn)
    def _check(*args,**kwargs):
        params = inspect.signature(fn).parameters
        inkeys = set(params.keys())
        invalues = tuple(params.values())
        for i,value in enumerate(args):
            if invalues[i].name == 'args':
                break
            if not isinstance(value, invalues[i].annotation):
                print(value, "is not type args", invalues[i].annotation)
        
        for k,v in kwargs.items():
            if k in inkeys and not isinstance(v, params[k].annotation):
                print(v, "is not type kwargs", params[k].annotation)
               
        return fn(*args,**kwargs)
    return _check

@check # add = check(add)
def add(x:int,y:int,z:int=0,j:int=0,*args,k:float=3.0,m:float,**kwargs)->int:
    return x+y+z+j

print(add(1,2.0,3,4.0, m=5, a=3,b=4,c=2))
print("--------------------------------------")
print(add(1, 2.0, 3, 4.0, 5, 6, 7.0, a=3,m=90))
#print(add.__name__, add.__annotations__, add.__closure__, add.__code__)

```