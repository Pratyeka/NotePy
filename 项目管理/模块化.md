### 基础概念
- 模块：一个py文件就是一个模块，方便管理代码
    - 模块也是封装，封装变量、类、函数
    - 模块就是命名空间，其内部的顶层标示符，都是他的属性，可以使用dir(module)看
- 包：==`目录 + __init__.py`，用来管理组织模块
    - 目录：可以作为模块来使用
    - __init__.py: 表示目录(模块)对应的代码
- 关系：
    - 包也是模块，但是模块不一定是包
    - 包是特殊的模块，是一种组织方式，包含__path__属性

### import
- 导入顶级模块：`import module`
    - 按照os.path路径找到指定的模块，*加载和初始化它，生成模块对象*
        - 找不到抛出ImportError异常
    - 将module加入到本地名称空间中，并绑定到模块对象
- 导入非顶级模块：`import module._module`
    - 只将顶级模块名称module加入到本地名词空间中
    - 只能使用完全限定名称访问：module._module
- as语句：`import module._module as newname`
    - newname直接绑定到导入的模块对象，并加入到本地名词空间中
    - 没有导入module到模块中
    - 直接使用：newname
- *注意：import 只能且必须是模块名*
- 导入多个模块时，分开独立导入，不建议连写
- 导入的多模块顺序建议：（防止三方模块以及自定义模块依赖系统模块出错）
    - 系统模块->三方模块->自定义模块
```Python
    import functools       # 导入模块
    print(dir())           # 输出当前模块中全部变量[...,functools]
    print(functools)
    print(functools.wraps) # 完全限定名访问

    import os.path
    print(dir())          # [...,os] 导入的是os
    print(os)
    print(os.path)        # 完全限定名访问

    import os.path as osp
    print(dir())            # 导入的是osp
    print(osp)
```

### from
- 导入指定模块成员：`from module import 模块/函数/类/变量`
- 导入指定模块公共成员: `from module(package) import *`
    - 如果模块没有__all__时，只导入所有的非下划线开头的成员
    - 如果是包,*子模块也不会导入*，除非在__all__中设置，或在__init__中像素导入
    - `__all__`: 是一个列表，元素是模块内的变量名，可以自定义*导入的成员
    - *注：可以使用__all__来防止导入大量无用模块*
```Python
    # 在当前名词空间导入该模块指定的成员
    from pathlib import Path, PosixPath
    print(dir())     # [...,Path, PosixPath]

    # 在当前名词空间中导入该模块所有公共成员或指定成员
    from pathlib import *
    print(dir()) 
```

- 导入成员别名: `from module import A as a, B as b, C`
    - a/b/C加入到当前的名词空间
- *注：初始化了module,但是没有加载到名词空间，存放在sys.modules*
- *注：from后一定且只能是模块*

- from方法总结：
    - 找到from子句指定的module模块，*加载并初始化它（不是导入）*
    - 对于import子句后的名称：
        - 先查module模块是否具有该名称的属性
        - 如果没有属性，尝试导入该名称的子模块
        - 如果没有找到抛出ImportError异常
        - *将该名称的保存到本地名词空间中*，如果有as子句，使用as子句名称

### 自定义模块
- 每一个.py文件就是一个模块
- 自定义模块命名规范：
    - 模块名就是文件名
    - 模块名必须符合标示符命名规范，否则在导入时会出错
    - 不要使用系统模块名，避免冲突
    - 模块名全小写，下划线来分割

### 模块搜索、加载
- 使用`sys.path`来查看模块的搜索顺序
    - 加载模块时，按搜索路径从前到后依次查找，并不搜索目录的子目录
    - sys.path可以被修改，追加新的目录
- 路径顺序：
    - 程序主目录：程序运行的主程序脚本所在目录
    - PYTHONPATH目录
    - 标准库目录，Python自带库模块所在目录

- 模块加载
    - 已加载的模块都存在`sys.modules`字典中（解释器初始化时就创建）
    - 模块不会重复加载

***
### 模块运行
- 解释器初始化时，会初始化sys.modules字典(保存已加载的模块)，创建builtins(全局函数、常量)模块、__main__模块、sys模块，以及模块搜索路径sys.path

- `__name__`: 默认是当前的模块名
    - 如果该模块作为主模块，将__name__修改为'__main__'
    - 模块的顶层代码就在__main__作用域中执行
- `if __name__ == "__main__"`作用：
    - 可以保存本模块的测试代码
    - 避免更换主模块时带来的副作用

- 模块的特殊属性：
    - `__file__`： 字符串，源文件的绝对路径
    - `__cached__`: 字符串，编译后的字节码文件路径
    - `__spec__`： 显示模块的规范
    - `__name__`: 模块名
    - `__package__`: 当模块是包，同__name__

### 包
- Python中，可以将目录作为模块（包），__init__.py文件代码包的内容
    - 目录也是文件，所以可以导入，目录代码通过__init__.py文件实现
- 包目录中的__init__.py是在包第一次导入的时候执行
    - __init__主要用于包的初始化工作
    - 好的代码习惯：保留__init__.py文件
- 包目录之间只能使用.点号作为分隔符，表示模块及其子模块的层级关系
- 子模块
    - 包下的模块以及目录都称为子模块
- *导入子模块一定会导入父模块，导入父模块一定不会导入子模块*

### 绝对导入、相对导入
- 绝对导入：
    - 在import语句或者from导入模块，模块名称最前面不是以.开头
    - 绝对导入总是在搜索模块的搜索路径中找
- 相对导入：
    - *只能在包内使用，且只能在from语句中*
    - .表示当前目录， ..表示上一级目录
    - *不要在顶层模块中使用相对导入*
```Python
    from . import d
    from .. import e
    from .d import e
```
- 使用相对导入的模块就是为了内部资源的互相引用

***
### 访问控制 
- 以_或者__开头的模块也可以被成功导入，因为都是合法的标示符，可以用作模块名
- 普通变量、保护变量、私有变量、特殊变量都没有被隐藏==模块内部没有私有变量，在模块内部不做特殊处理， 可以使用from语句访问所有变量

***
### 总结
- 模块也是封装，如同类、函数，不过它封装的是变量、类、函数
- 模块就是命名空间，内部的顶层标示符都是它的属性，可以通过__dict__或者dir查看
- 包也是模块，但模块不一定是包，包是特殊的模块，是一种组织方式