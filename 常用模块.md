***
### 随机数生成
随机数生成模块：`random`，主要的方法介绍：
- `randint(a,b)`：从[a,b]区间内随机返回一个整数值
- `choice(sequence)`：在序列中随机选择一个整数返回
- `randrange([start,] end [,step])`：在[start , end) 区间内随机取一个值，并且可以设置步长
- `shuffle(sequence)` ：对sequence序列进行打乱排序，就地操作
- `sample(population, num)`：对population随机采样num个不同的元素构成列表返回

***
### 函数运行计时
计时模块：`datetime`，主要方法介绍：
  - datetime对象
  - `datetime.today()`: 返回本地时区当前的datetime对象
  - `datetime.now()`：获取系统当前时间的datetime对象，时间到微秒
  - `datetime.fromtimestamp(int)`: 根据输入的时间戳返回当前时区的标准时间
  - `object.timestamp()`: 返回一个到微秒的时间戳
  - `object.strftime(self, format)`: 将一个datetime类型的数据按照设定格式转为字符串类型时间
  - `datetime.srtptime(cls, date_str, format)`: 
    - `date_str`:字符串时间戳
    - `format`:字符串对应的格式解析符，
    - 返回一个datetime对象 
```
  import datetime
  time_stamp = datetime.datetime.now(tz = datetime.timezone.utc)
  print(time_stamp.strftime("%y-%m-%d %H:%M:%S"))
  time_stamp = datetime.datetime.now(tz = None)
  print(time_stamp.strftime("%y-%m-%d %H:%M:%S")) # 解析时间戳为字符串
  print(datetime.datetime.strptime("2018-12-12 23:23:23", "%Y-%m-%d %H:%M:%S")) # 按照字符串指定格式解析时间字符串，返回datetime实例
```
- timedelta对象
  - `datetime.timedelta.total_seconds() `：将两个时间只差转换成秒计时的格式输出
  - `datetime = datetime + timedelta`
  - `datetime = datetime - timedelta`
  - `timedelta = datetime - detetime`

***
### 时间模块
时间模块：`time`
- `time.sleep(t)`：设置当前程序休息t秒

***
### collections
- namedtuple:(具名元祖，用来实现有少量属性且没有类方法的类对象的创建)
  - 语法：`xx = namedtuple(xxX, 'ele1,ele2,...,elen')`
    - `xx`:类关键字
    - `xxX`:类名（一般会与xx写成一样）
    - `'ele1,ele2,...,elen'`:类的各字段名称
    - xx(ele1:v1, ele2:v2, ... , elen:vn) ：带字段的元祖
  - 使用：`newObject = xx(a1,a2,...,an)`
  - 访问：`newObject.a1   newObject.a2`
  - 访问：`newObject[0]`
  - 关键属性：
    - `_fields`：包含类中所有字段名称的元祖
    - `_make()`：接受一个可迭代对象来生成类实例
    - `_asdict()`：将数据按照有序字典的形式返回

***
- OrderedDict
  - 语法：`oDic = OrderedDict()`
  - 使用方法与普通字典一样
  - 字典中元素按照添加的顺序存放
- defaultdict
  - 语法：`defaultdict(default_factory[, ...]) --> dict`
  - 使用：字典中没有key时，自动按照工厂方法新建value，构成kv对

***
### functiontools
- warp : 装饰器函数，将被装饰函数的元数据传递给装饰函数
  - 语法：`@functiontools.warp(fn)`
  - 内部使用了偏函数（将update函数构造成只接受包装函数对象的函数）

- partial : 构建偏函数，固定函数的部分参数，返回一个新函数
  - 语法：`@functiontools.partial(fn)`
  - 主要是将一个函数可接受的参数分为两个函数完成，部分固定，部分待输入
  - 两部分的参数合在一起，必须满足原函数的实参赋值要求

- lru_cache : 缓存技术
  - 语法：`@lru_cache(128,True)`：装饰器缓存
  - 128： 表示缓存空间的大小
  - True：表示是否将大小相同的整形和浮点型数据看成同一个数据

***
### inspect
- signature : 返回原函数的签名信息
  - 语法：`inspect.signature(fn)->signature object`
  - 用来返回一个签名类对象，主要属性
    - return_annotation ：返回值的类型
    - parameters：参数构成的有序字典，其中value是一个param类

    - parms类对象的主要属性：
      - annotation：类型注释
      - name：对应的key值
      - default：如果是缺省值，其中存放的缺省值数据
      - empty： 空类型
      - kind：参数类型（位置/关键字参数、可变参数、kw-only参数、可变关键字参数）

***
### bisect
- bisect: 二分法模块（order_lst默认是升序的列表）
  - 语法：`bisect.bisect(order_lst, insert_value, low, hight)`: 返回数据插入的的索引值
    - 默认调用`bisect.bisect_right`，碰到大小相同的数值，放在最右侧
  - `bisect.bisect_right(order_lst, insert_value, low, hight)`: 返回数据插入点的索引值
    - 碰到大小相同的数据，放在最右侧
  - `bisect.bisect_left(order_lst, insert_value, low, hight)`: 返回数据插入点的索引值
    - 碰到大小相同的数据，放在最左边

  - `bisect.insort(order_lst, insert_value, low, hight)`: 完成对order_lst的数据插入操作
    - 默认将大小一致的数据插入到最右侧
  - `bisect.insort_right(order_lst, insert_value, low, hight)`: 完成对order_lst的数据插入操作
    - 默认将大小一致的数据插入到最右侧
  - `bisect.insort_left(order_lst, insert_value, low, hight)`
    - 默认将大小一致的数据插入到最左侧

***
### contextlib
- 语法：`@contextlib.contextmanager`: 装饰器函数
- 装饰一个函数实现上下文管理，不用像类一样实现`__enter__`/`__exit__`
- 基本语法是：
```
import context

@context.contextmanager
def foo():
    <setup> : 类似于__enter__函数功能
  try：
    yield 语句
  finally：
    <cleanup> : 类似于__exit__函数功能

with foo() as f:
  print(f)
```
- *** 注意 ***: 要求函数必须是生成器函数
  - `f`接收 yield 语句的返回值
